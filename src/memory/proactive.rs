//! Proactive suggestion engine for anticipating user needs.
//!
//! This module analyzes patterns, goals, and past experiences to generate
//! contextually relevant suggestions.

use crate::traits::{BehaviorPattern, Episode, Goal, Procedure, UserProfile};
use crate::utils::truncate_str;

/// A suggestion generated by the proactive engine.
#[derive(Debug, Clone)]
pub struct Suggestion {
    pub text: String,
    #[allow(dead_code)] // Reserved for tracking suggestion provenance
    pub source: SuggestionSource,
    #[allow(dead_code)] // Used internally for sorting
    pub confidence: f32,
}

/// The source of a proactive suggestion.
#[derive(Debug, Clone)]
#[allow(dead_code)] // IDs reserved for feedback/analytics
pub enum SuggestionSource {
    Pattern(i64),   // Behavior pattern ID
    Goal(i64),      // Goal ID
    Procedure(i64), // Procedure ID
    Episode(i64),   // Episode ID
}

/// Context for generating suggestions.
pub struct SuggestionContext {
    pub last_action: Option<String>,
    pub current_topic: Option<String>,
    #[allow(dead_code)] // Reserved for time-based suggestions
    pub session_duration_mins: i32,
    #[allow(dead_code)] // Reserved for complexity-based suggestions
    pub tool_call_count: i32,
    #[allow(dead_code)] // Reserved for error-recovery suggestions
    pub has_errors: bool,
    pub user_message: String,
}

/// The proactive suggestion engine.
pub struct ProactiveEngine {
    patterns: Vec<BehaviorPattern>,
    goals: Vec<Goal>,
    procedures: Vec<Procedure>,
    recent_episodes: Vec<Episode>,
    profile: UserProfile,
}

impl ProactiveEngine {
    pub fn new(
        patterns: Vec<BehaviorPattern>,
        goals: Vec<Goal>,
        procedures: Vec<Procedure>,
        recent_episodes: Vec<Episode>,
        profile: UserProfile,
    ) -> Self {
        Self {
            patterns,
            goals,
            procedures,
            recent_episodes,
            profile,
        }
    }

    /// Get suggestions based on the current context.
    pub fn get_suggestions(&self, context: &SuggestionContext) -> Vec<Suggestion> {
        // If user doesn't like suggestions, return empty
        if !self.profile.likes_suggestions {
            return vec![];
        }

        let mut suggestions = vec![];

        // 1. Pattern-based suggestions
        suggestions.extend(self.pattern_suggestions(context));

        // 2. Goal-based suggestions
        suggestions.extend(self.goal_suggestions(context));

        // 3. Procedure-based suggestions
        suggestions.extend(self.procedure_suggestions(context));

        // 4. Episode-based suggestions
        suggestions.extend(self.episode_suggestions(context));

        // Sort by confidence and deduplicate
        suggestions.sort_by(|a, b| {
            b.confidence
                .partial_cmp(&a.confidence)
                .unwrap_or(std::cmp::Ordering::Equal)
        });

        // Keep top 3
        suggestions.truncate(3);

        suggestions
    }

    /// Get the top suggestion if above confidence threshold.
    #[allow(dead_code)] // Reserved for single-suggestion mode
    pub fn get_top_suggestion(
        &self,
        context: &SuggestionContext,
        min_confidence: f32,
    ) -> Option<Suggestion> {
        self.get_suggestions(context)
            .into_iter()
            .find(|s| s.confidence >= min_confidence)
    }

    /// Generate suggestions based on behavior patterns.
    fn pattern_suggestions(&self, context: &SuggestionContext) -> Vec<Suggestion> {
        let mut suggestions = vec![];

        for pattern in &self.patterns {
            if pattern.confidence < 0.6 {
                continue;
            }

            // Check if pattern trigger matches context
            let matches = match pattern.pattern_type.as_str() {
                "sequence" => {
                    // Sequence patterns: check if last action matches trigger
                    pattern.trigger_context.as_ref().is_some_and(|trigger| {
                        context.last_action.as_ref().is_some_and(|action| {
                            action.to_lowercase().contains(&trigger.to_lowercase())
                        })
                    })
                }
                "trigger" => {
                    // Trigger patterns: check user message
                    pattern.trigger_context.as_ref().is_some_and(|trigger| {
                        context
                            .user_message
                            .to_lowercase()
                            .contains(&trigger.to_lowercase())
                    })
                }
                "habit" => {
                    // Habit patterns: time-based or frequency-based
                    // For now, just check occurrence count
                    pattern.occurrence_count >= 3
                }
                _ => false,
            };

            if matches {
                if let Some(action) = &pattern.action {
                    suggestions.push(Suggestion {
                        text: format!("Based on your usual pattern: {}", action),
                        source: SuggestionSource::Pattern(pattern.id),
                        confidence: pattern.confidence,
                    });
                }
            }
        }

        suggestions
    }

    /// Generate suggestions based on active goals.
    fn goal_suggestions(&self, context: &SuggestionContext) -> Vec<Suggestion> {
        let mut suggestions = vec![];

        for goal in &self.goals {
            if goal.status != "active" {
                continue;
            }

            // Check if current context relates to the goal
            let relevant = context.user_message.to_lowercase().contains(
                goal.description
                    .to_lowercase()
                    .split_whitespace()
                    .next()
                    .unwrap_or(""),
            ) || context.current_topic.as_ref().is_some_and(|topic| {
                goal.description
                    .to_lowercase()
                    .contains(&topic.to_lowercase())
            });

            if relevant {
                let confidence = match goal.priority.as_str() {
                    "high" => 0.8,
                    "medium" => 0.6,
                    _ => 0.4,
                };

                suggestions.push(Suggestion {
                    text: format!("This relates to your goal: {}", goal.description),
                    source: SuggestionSource::Goal(goal.id),
                    confidence,
                });
            }
        }

        suggestions
    }

    /// Generate suggestions based on known procedures.
    fn procedure_suggestions(&self, context: &SuggestionContext) -> Vec<Suggestion> {
        let mut suggestions = vec![];

        for procedure in &self.procedures {
            // Only suggest procedures with good track record
            if procedure.success_count <= procedure.failure_count {
                continue;
            }

            // Check if trigger pattern matches
            let matches = context
                .user_message
                .to_lowercase()
                .contains(&procedure.trigger_pattern.to_lowercase());

            if matches {
                let success_rate = procedure.success_count as f32
                    / (procedure.success_count + procedure.failure_count) as f32;

                suggestions.push(Suggestion {
                    text: format!("I know how to handle this (procedure: {})", procedure.name),
                    source: SuggestionSource::Procedure(procedure.id),
                    confidence: success_rate * 0.8, // Scale down slightly
                });
            }
        }

        suggestions
    }

    /// Generate suggestions based on similar past episodes.
    fn episode_suggestions(&self, context: &SuggestionContext) -> Vec<Suggestion> {
        let mut suggestions = vec![];

        for episode in &self.recent_episodes {
            // Check if topics overlap
            let topic_match = episode.topics.as_ref().is_some_and(|topics| {
                topics.iter().any(|t| {
                    context
                        .user_message
                        .to_lowercase()
                        .contains(&t.to_lowercase())
                })
            });

            if topic_match {
                let confidence = episode.importance * 0.6; // Scale by importance

                suggestions.push(Suggestion {
                    text: format!(
                        "We've worked on something similar before: {}",
                        truncate_str(&episode.summary, 50)
                    ),
                    source: SuggestionSource::Episode(episode.id),
                    confidence,
                });
            }
        }

        suggestions
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use chrono::Utc;

    fn make_profile(likes_suggestions: bool) -> UserProfile {
        UserProfile {
            id: 1,
            verbosity_preference: "medium".to_string(),
            explanation_depth: "moderate".to_string(),
            tone_preference: "neutral".to_string(),
            emoji_preference: "none".to_string(),
            typical_session_length: None,
            active_hours: None,
            common_workflows: None,
            asks_before_acting: true,
            prefers_explanations: true,
            likes_suggestions,
            updated_at: Utc::now(),
        }
    }

    #[test]
    fn test_no_suggestions_when_disabled() {
        let engine = ProactiveEngine::new(vec![], vec![], vec![], vec![], make_profile(false));

        let context = SuggestionContext {
            last_action: None,
            current_topic: None,
            session_duration_mins: 5,
            tool_call_count: 0,
            has_errors: false,
            user_message: "test".to_string(),
        };

        let suggestions = engine.get_suggestions(&context);
        assert!(suggestions.is_empty());
    }

    #[test]
    fn test_goal_suggestion() {
        let goal = Goal {
            id: 1,
            description: "Complete the Rust migration".to_string(),
            status: "active".to_string(),
            priority: "high".to_string(),
            progress_notes: None,
            source_episode_id: None,
            created_at: Utc::now(),
            updated_at: Utc::now(),
            completed_at: None,
        };

        let engine = ProactiveEngine::new(vec![], vec![goal], vec![], vec![], make_profile(true));

        let context = SuggestionContext {
            last_action: None,
            current_topic: Some("rust".to_string()),
            session_duration_mins: 5,
            tool_call_count: 0,
            has_errors: false,
            user_message: "Help me with Rust".to_string(),
        };

        let suggestions = engine.get_suggestions(&context);
        assert!(!suggestions.is_empty());
    }
}
